<script>
const API_URL = "https://mm-courier-route-planner.onrender.com";

// Initialize Leaflet map
const map = L.map("map").setView([-26.2041, 28.0473], 11);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "Â© OpenStreetMap contributors",
}).addTo(map);
map.invalidateSize(); // Fix half map render

let stops = [];
let markers = [];
let routeLine;
let currentStopIndex = 0; // track which stop the driver is on

// ----------------------
// Google Places Autocomplete
// ----------------------
let autocomplete;
function initAutocomplete() {
  const input = document.getElementById("newAddress");
  autocomplete = new google.maps.places.Autocomplete(input, { types: ["geocode"] });
}

// ----------------------
// Add stop from autocomplete
// ----------------------
document.getElementById("addStop").addEventListener("click", () => {
  const place = autocomplete.getPlace();
  if (!place || !place.geometry) {
    alert("Please select a valid address from suggestions");
    return;
  }

  const lat = place.geometry.location.lat();
  const lon = place.geometry.location.lng();
  stops.push({ lat, lon });

  const marker = L.marker([lat, lon]).addTo(map);
  marker.bindPopup(`Stop ${stops.length}`).openPopup();
  markers.push(marker);

  map.setView([lat, lon], 12);
  document.getElementById("newAddress").value = "";
});

// ----------------------
// Load optimized route
// ----------------------
async function loadRoute() {
  if (stops.length < 2) {
    alert("Please add at least two stops");
    return;
  }

  try {
    const res = await fetch(`${API_URL}/optimize`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ stops }),
    });

    if (!res.ok) throw new Error("Failed to fetch route");

    const data = await res.json();
    if (!data.routes || data.routes.length === 0) throw new Error("No route found");

    const coords = decodePolyline(data.routes[0].overview_polyline.points);

    if (routeLine) map.removeLayer(routeLine);
    routeLine = L.polyline(coords, { color: "blue" }).addTo(map);

    map.fitBounds(routeLine.getBounds());

    currentStopIndex = 0; // reset driver progress
    highlightCurrentStop();
  } catch (err) {
    console.error(err);
    alert("Error optimizing route. Check console.");
  }
}

document.getElementById("loadRoute").addEventListener("click", loadRoute);

// ----------------------
// Highlight current stop
// ----------------------
function highlightCurrentStop() {
  markers.forEach((m, i) => {
    if (i === currentStopIndex) m.setIcon(new L.Icon.Default({ className: "current-stop" }));
  });
}

// ----------------------
// Mark stop delivered & go to next
// ----------------------
async function markDeliveredNext() {
  if (currentStopIndex >= stops.length) {
    alert("All stops completed!");
    return;
  }

  const stopId = currentStopIndex + 1;
  try {
    const res = await fetch(`${API_URL}/mark-delivered`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ stopId }),
    });
    const data = await res.json();
    console.log(data);

    alert(`Stop ${stopId} delivered!`);

    // Move to next stop
    currentStopIndex++;
    if (currentStopIndex < stops.length) {
      const next = stops[currentStopIndex];
      map.setView([next.lat, next.lon], 15);

      // Open Google Maps navigation
      const url = `https://www.google.com/maps/dir/?api=1&destination=${next.lat},${next.lon}&travelmode=driving`;
      window.open(url, "_blank");
    } else {
      alert("All stops completed!");
    }
  } catch (err) {
    console.error(err);
    alert("Failed to mark stop delivered");
  }
}

// ----------------------
// Decode polyline from Google
// ----------------------
function decodePolyline(str, precision = 5) {
  let index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null;
  const factor = Math.pow(10, -precision);

  while (index < str.length) {
    byte = null; shift = 0; result = 0;
    do {
      byte = str.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);
    const deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
    lat += deltaLat;

    shift = 0; result = 0;
    do {
      byte = str.charCodeAt(index++) - 63;
      result |= (byte & 0x1f) << shift;
      shift += 5;
    } while (byte >= 0x20);
    const deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
    lng += deltaLng;

    coordinates.push([lat * factor, lng * factor]);
  }
  return coordinates;
}

// ----------------------
// Add "Mark Delivered" button dynamically
// ----------------------
const btn = document.createElement("button");
btn.textContent = "Mark Delivered & Next Stop";
btn.className = "bg-yellow-600 text-white px-4 py-2 rounded hover:bg-yellow-700 mt-4";
btn.onclick = markDeliveredNext;
document.body.appendChild(btn);
</script>
